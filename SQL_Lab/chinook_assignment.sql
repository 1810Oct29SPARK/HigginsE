-- SQL LAB CHINOOK HOMEWORK ASSIGNMENT --
-- AUTHOR: EDDY SOMA --
-- FINISHED ON 2018-12-08 @ 22:23 EST --


-- ==========SECTION 2 SQL QUERIES========== --

-- 2.1 SELECT --

-- TASK: SELECT ALL RECORDS FROM THE EMPLOYEE TABLE.
SELECT * FROM EMPLOYEE;

-- TASK: SELECT ALL RECORDS FROM THE EMPLOYEE TABLE WHERE LAST NAME IS KING.
SELECT * FROM EMPLOYEE
WHERE LASTNAME = 'King';

-- TASK: SELECT ALL RECORDS FROM THE EMPLOYEE TABLE WHERE FIRST NAME IS ANDREW AND REPORTSTO IS NULL.
SELECT * FROM EMPLOYEE
WHERE FIRSTNAME = 'Andrew' AND REPORTSTO IS NULL;

-- 2.2 ORDER BY --

-- TASK: SELECT ALL ALBUMS IN ALBUM TABLE AND SORT RESULT SET IN DESCENDING ORDER BY TITLE.
SELECT * FROM ALBUM
ORDER BY TITLE DESC;

-- TASK: SELECT FIRST NAME FROM CUSTOMER AND SORT RESULT SET IN ASCENDING ORDER BY CITY.
SELECT FIRSTNAME FROM CUSTOMER
ORDER BY CITY ASC;

-- 2.3 INSERT INTO --

-- TASK: INSERT TWO NEW RECORDS INTO GENRE TABLE.
INSERT INTO GENRE
VALUES (26, 'Lisztomania');
/
INSERT INTO GENRE
VALUES (27, 'Falcom');

-- TASK: INSERT TWO NEW RECORDS INTO EMPLOYEE TABLE.
INSERT INTO EMPLOYEE
(EMPLOYEEID, LASTNAME, FIRSTNAME, TITLE, REPORTSTO, EMAIL)
VALUES (9, 'Hancock', 'John', 'IT Staff', 6, 'john@chinookcorp.com');
/
INSERT INTO EMPLOYEE
(EMPLOYEEID, LASTNAME, FIRSTNAME, TITLE, REPORTSTO, EMAIL)
VALUES (10, 'Sam', 'Raiden', 'IT Staff', 6, 'raiden@chinookcorp.com');

-- TASK: INSERT TWO NEW RECORDS INTO CUSTOMER TABLE.
INSERT INTO CUSTOMER
(CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL, SUPPORTREPID)
VALUES (60, 'George', 'Li', 'george.li@gmail.com', 3);
/
INSERT INTO CUSTOMER
(CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL, SUPPORTREPID)
VALUES (61, 'Felix', 'Sharp', 'felix.sharp@gmail.com', 5);

-- 2.4 UPDATE --

-- TASK: UPDATE AARON MITCHELL IN CUSTOMER TABLE TO ROBERT WALTER.
UPDATE CUSTOMER
SET FIRSTNAME = 'Robert', LASTNAME = 'Walter'
WHERE FIRSTNAME = 'Aaron' AND LASTNAME = 'Mitchell';

-- TASK: UPDATE NAME OF ARTIST IN THE ARTIST TABLE "CREEDENCE CLEARWATER REVIVAL" TO "CCR".
UPDATE ARTIST
SET NAME = 'CCR'
WHERE NAME = 'Creedence Clearwater Revival';

-- 2.5 LIKE --

-- TASK: SELECT ALL INVOICES WITH A BILLING ADDRESS LIKE "T%".
SELECT * FROM INVOICE
WHERE BILLINGADDRESS LIKE 'T%';

-- 2.6 BETWEEN --

-- TASK: SELECT ALL INVOICES THAT HAVE A TOTAL BETWEEN 15 AND 50.
SELECT * FROM INVOICE
WHERE TOTAL BETWEEN 15 AND 50;

-- TASK: SELECT ALL EMPLOYEES HIRED BETWEEN 1ST OF JUNE 2003 AND 1ST OF MARCH 2004.
SELECT * FROM EMPLOYEE
WHERE HIREDATE BETWEEN '2003-06-01' AND '2004-03-01';

-- 2.7 DELETE --

-- TASK: DELETE A RECORD IN CUSTOMER TABLE WHERE THE NAME IS ROBERT WALTER.

-- ADD FOREIGN KEY CONSTRAINTS WITH CASCADE DELETE
ALTER TABLE INVOICELINE
DROP CONSTRAINT FK_INVOICELINEINVOICEID;
/
ALTER TABLE INVOICELINE
ADD CONSTRAINT FK_INVOICELINEINVOICEID
FOREIGN KEY (INVOICEID) REFERENCES INVOICE (INVOICEID)
ON DELETE CASCADE;

ALTER TABLE INVOICE
DROP CONSTRAINT FK_INVOICECUSTOMERID;
/
ALTER TABLE INVOICE
ADD CONSTRAINT FK_INVOICECUSTOMERID
FOREIGN KEY (CUSTOMERID) REFERENCES CUSTOMER (CUSTOMERID)
ON DELETE CASCADE;

-- UPDATE CUSTOMER
UPDATE CUSTOMER
SET FIRSTNAME = 'Robert', LASTNAME = 'Walter'
WHERE FIRSTNAME = 'Aaron' AND LASTNAME = 'Mitchell';
/
-- DELETE CUSTOMER
DELETE FROM CUSTOMER
WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter';


-- ==========SECTION 3 SQL FUNCTIONS========== --

-- 3.1 SYSTEM DEFINED FUNCTIONS --

-- TASK: CREATE A FUNCTION THAT RETURNS THE CURRENT TIME.
CREATE OR REPLACE FUNCTION GET_CURRENT_TIME
	RETURN VARCHAR2
IS
	CURRENT_DATE VARCHAR2(20);
	CURRENT_TIME VARCHAR2(20);
BEGIN
	CURRENT_DATE := TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD');
	CURRENT_TIME := TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI:SS');
	RETURN 'CURRENT TIME: ' || CURRENT_DATE || ' @ ' || CURRENT_TIME;
END;

-- TASK: CREATE A FUNCTION THAT RETURNS THE LENGTH OF NAME IN MEDIATYPE TABLE.
CREATE OR REPLACE FUNCTION GET_MEDIATYPE_LENGTH_BY_ID
	(M_ID IN INT)
	RETURN INT
IS
	M_NAME VARCHAR2(50);
BEGIN
	SELECT NAME INTO M_NAME
	FROM MEDIATYPE
	WHERE MEDIATYPEID = M_ID;
	RETURN LENGTH(M_NAME);
END;

-- 3.2 SYSTEM DEFINED AGGREGATE FUNCTIONS --

-- TASK: CREATE A FUNCTION THAT RETURNS THE AVERAGE TOTAL OF ALL INVOICES.
CREATE OR REPLACE FUNCTION GET_AVG_INVOICE_TOTAL
	RETURN NUMBER
IS
	AVG_TOTAL NUMBER;
BEGIN
	SELECT AVG(TOTAL) INTO AVG_TOTAL
	FROM INVOICE;
	RETURN ROUND(AVG_TOTAL, 2);
END;

-- TASK: CREATE A FUNCTION THAT RETURNS THE MOST EXPENSIVE TRACK.
-- (THIS TASK IS DIVIDED INTO TWO PARTS SINCE MANY TRACKS ALL HAVE THE HIGHEST UNITPRICE)

-- THE FOLLOWING FUNCTION RETURNS THE UNITPRICE OF THE MOST EXPENSIVE TRACK
CREATE OR REPLACE FUNCTION GET_HIGHEST_TRACK_PRICE
	RETURN NUMBER
IS
	HI_PRICE NUMBER;
BEGIN
	SELECT MAX(UNITPRICE) INTO HI_PRICE
	FROM TRACK;
	RETURN HI_PRICE;
END;

-- THE FOLLOWING FUNCTION RETURNS A CURSOR POINTING TO A SELECTION OF ALL TRACKS HAVING THE HIGHEST UNITPRICE
CREATE OR REPLACE FUNCTION GET_EXPENSIVE_CURSOR
	RETURN SYS_REFCURSOR
IS
	HI_PRICE NUMBER;
	EXP_CUR SYS_REFCURSOR;
BEGIN
	HI_PRICE := GET_HIGHEST_TRACK_PRICE;
	OPEN EXP_CUR FOR
	SELECT NAME, UNITPRICE
	FROM TRACK
	WHERE UNITPRICE = HI_PRICE;
	RETURN EXP_CUR;
END;

-- 3.3 USER DEFINED SCALAR FUNCTIONS --

-- TASK: CREATE A FUNCTION THAT RETURNS THE AVERAGE PRICE OF INVOICELINE ITEMS IN THE INVOICELINE TABLE.
CREATE OR REPLACE FUNCTION GET_AVG_LINE_ITEM_PRICE
	RETURN NUMBER
IS
	TOTAL_PRICE NUMBER;
	TOTAL_ITEMS INT;
	ITEM_PRICE NUMBER;
	LINE_QUAN INT;
	-- DECLARE CURSOR
	CURSOR LINE_CUR
	IS
		SELECT UNITPRICE, QUANTITY
		FROM INVOICELINE;
BEGIN
	TOTAL_PRICE := 0;
	TOTAL_ITEMS := 0;
	OPEN LINE_CUR;
	LOOP
		FETCH LINE_CUR INTO ITEM_PRICE, LINE_QUAN;
		EXIT WHEN LINE_CUR%NOTFOUND;
		TOTAL_ITEMS := TOTAL_ITEMS + 1;
		TOTAL_PRICE := TOTAL_PRICE + (ITEM_PRICE * LINE_QUAN);
	END LOOP;
	RETURN ROUND(TOTAL_PRICE / TOTAL_ITEMS, 2);
END;

-- 3.4 USER DEFINED TABLE VALUED FUNCTIONS

-- TASK: CREATE A FUNCTION THAT RETURNS ALL EMPLOYEES WHO ARE BORN AFTER 1968.
-- (THIS TASK IS DIVIDED INTO TWO PARTS)

-- THE FOLLOWING FUNCTION RETURNS A CURSOR POINTING TO THE SELECTION OF ALL EMPLOYEES BORN AFTER 1968
CREATE OR REPLACE FUNCTION GET_EMPLOYEES_1968
	RETURN SYS_REFCURSOR
IS
	EMP_CUR SYS_REFCURSOR;
BEGIN
	OPEN EMP_CUR FOR
	SELECT FIRSTNAME, LASTNAME, BIRTHDATE
	FROM EMPLOYEE
	WHERE BIRTHDATE > '1967-12-31';
	RETURN EMP_CUR;
END;

-- THE FOLLOWING FUNCTION RETURNS A STRING OF NAMES OF THE EMPLOYEES BORN AFTER 1968
CREATE OR REPLACE FUNCTION GET_1968_NAME_LIST
	RETURN VARCHAR2
IS
	EMP_CUR SYS_REFCURSOR;
	NAME_LIST VARCHAR2(4000);
	F_NAME EMPLOYEE.FIRSTNAME%TYPE;
	L_NAME EMPLOYEE.LASTNAME%TYPE;
	B_DATE EMPLOYEE.BIRTHDATE%TYPE;
BEGIN
	EMP_CUR := GET_EMPLOYEES_1968;
	NAME_LIST := '';
	LOOP
		FETCH EMP_CUR INTO F_NAME, L_NAME, B_DATE;
		EXIT WHEN EMP_CUR%NOTFOUND;
		IF NAME_LIST IS NOT NULL THEN
		NAME_LIST := NAME_LIST || CHR(13) || CHR(10);
		END IF;
		NAME_LIST := NAME_LIST || F_NAME || ' ' || L_NAME || ' BORN ON ' || TO_CHAR(B_DATE, 'YYYY-MM-DD');
	END LOOP;
	RETURN NAME_LIST;
END;


-- ==========SECTION 4 STORED PROCEDURES========== --

-- 4.1 BASIC STORED PROCEDURE --

-- TASK: CREATE A STORED PROCEDURE THAT SELECTS THE FIRST AND LAST NAMES OF ALL THE EMPLOYEES.

-- THE FOLLOWING PROCEDURE SIMPLY PRINTS ALL EMPLOYEE NAMES INTO THE CONSOLE
CREATE OR REPLACE PROCEDURE PRINT_EMPLOYEE_NAMES
IS
	F_NAME EMPLOYEE.FIRSTNAME%TYPE;
	L_NAME EMPLOYEE.LASTNAME%TYPE;
	CURSOR EMP_CUR
	IS
		SELECT FIRSTNAME, LASTNAME
		FROM EMPLOYEE
		ORDER BY EMPLOYEEID;
BEGIN
	OPEN EMP_CUR;
	LOOP
		FETCH EMP_CUR INTO F_NAME, L_NAME;
		EXIT WHEN EMP_CUR%NOTFOUND;
		DBMS_OUTPUT.PUT_LINE(F_NAME || ' ' || L_NAME);
	END LOOP;
END;

-- 4.2 STORED PROCEDURE INPUT PARAMETERS --

-- TASK: CREATE A STORED PROCEDURE THAT UPDATES THE PERSONAL INFORMATION OF AN EMPLOYEE.

-- THE FOLLOWING PROCEDURE EXECUTES A DYNAMIC SQL STRING FOR BETTER USER EXPERIENCE
-- BUT IT IS VULNERABLE TO SQL INJECTION
-- USER WILL ENTER EMPLOYEEID, COLUMN NAME, AND A NEW VALUE AS ARGUMENTS
CREATE OR REPLACE PROCEDURE UPDATE_EMPLOYEE_INFO
	(E_ID IN INT, COL_NAME IN VARCHAR2, N_VAL IN VARCHAR2)
IS
	SQL_STMT VARCHAR2(500);
	SQL_INPUT VARCHAR2(200);
BEGIN
	SQL_STMT := 'BEGIN UPDATE EMPLOYEE SET ' || COL_NAME || ' = ';
	IF COL_NAME = 'BIRTHDATE' OR COL_NAME = 'HIREDATE' THEN
		SQL_INPUT := 'TO_DATE(''' || N_VAL || ''', ''YYYY-MM-DD'') ';
	ELSE
		SQL_INPUT := '''' || N_VAL || '''' || ' ';
	END IF;
	SQL_STMT := SQL_STMT || SQL_INPUT || 'WHERE EMPLOYEEID = ' || E_ID || '; END;';
	EXECUTE IMMEDIATE SQL_STMT;
	DBMS_OUTPUT.PUT_LINE('EMPLOYEE# ' || E_ID || ' UPDATED');
	EXCEPTION
		WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('UPDATE FAILED');
		ROLLBACK;
END;

-- TASK: CREATE A STORED PROCEDURE THAT RETURNS THE MANAGERS OF AN EMPLOYEE.
-- (THIS TASK HAS TWO VERSIONS)

-- THE FOLLOWING PROCEDURE RETURNS THE MANAGER'S EMPLOYEEID AND FULL NAME OF AN EMPLOYEE
CREATE OR REPLACE PROCEDURE FIND_MANAGER_BY_ID
	(E_ID IN INT, M_ID OUT INT, M_NAME OUT VARCHAR2)
IS
	F_NAME EMPLOYEE.FIRSTNAME%TYPE;
	L_NAME EMPLOYEE.LASTNAME%TYPE;
BEGIN
	SELECT REPORTSTO INTO M_ID
	FROM EMPLOYEE
	WHERE EMPLOYEEID = E_ID;
	IF M_ID IS NULL THEN
		DBMS_OUTPUT.PUT_LINE('NO MANAGER FOUND');
	ELSE
		SELECT FIRSTNAME, LASTNAME INTO F_NAME, L_NAME
		FROM EMPLOYEE
		WHERE EMPLOYEEID = M_ID;
		M_NAME := F_NAME || ' ' || L_NAME;
	END IF;
END;

-- THE FOLLOWING PROCEDURE WILL PRINT OUT THE ENTIRE MANAGEMENT HIERARCHY
CREATE OR REPLACE PROCEDURE FIND_ALL_MANAGERS
	(E_ID IN INT)
IS
	C_ID INT;
	M_ID INT;
	F_NAME EMPLOYEE.FIRSTNAME%TYPE;
	L_NAME EMPLOYEE.LASTNAME%TYPE;
	M_RESULT VARCHAR(1000);
BEGIN
	C_ID := E_ID;
	M_RESULT := '';
	LOOP
		SELECT REPORTSTO INTO M_ID
		FROM EMPLOYEE
		WHERE EMPLOYEEID = C_ID;
		EXIT WHEN M_ID IS NULL;
		IF M_RESULT IS NOT NULL THEN
			M_RESULT := M_RESULT || CHR(13) || CHR(10);
		END IF;
		SELECT FIRSTNAME, LASTNAME INTO F_NAME, L_NAME
		FROM EMPLOYEE
		WHERE EMPLOYEEID = M_ID;
		M_RESULT := M_RESULT || F_NAME || ' ' || L_NAME;
		C_ID := M_ID;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE(M_RESULT);
END;

-- 4.3 STORED PROCEDURE OUTPUT PARAMETERS --

-- TASK: CREATE A STORED PROCEDURE THAT RETURNS THE NAME AND COMPANY OF A CUSTOMER.
CREATE OR REPLACE PROCEDURE FIND_NAME_COMPANY_BY_ID
	(C_ID IN INT, C_NAME OUT VARCHAR2, C_COMP OUT CUSTOMER.COMPANY%TYPE)
IS
	F_NAME CUSTOMER.FIRSTNAME%TYPE;
	L_NAME CUSTOMER.LASTNAME%TYPE;
BEGIN
	SELECT FIRSTNAME, LASTNAME, COMPANY INTO F_NAME, L_NAME, C_COMP
	FROM CUSTOMER
	WHERE CUSTOMERID = C_ID;
	IF F_NAME IS NULL THEN
		DBMS_OUTPUT.PUT_LINE('CUSTOMER NOT FOUND');
	ELSE
		C_NAME := '' || F_NAME || ' ' || L_NAME;
	END IF;
END;


-- ==========SECTION 5 TRANSACTIONS========== --

-- TASK: CREATE A TRANSACTION THAT GIVEN A INVOICEID WILL DELETE THAT INVOICE.

-- THE FOREIGN KEY CONSTRAINT OF INVOICELINE IS ALREADY SET TO CASCADE DELETE IN THE TASK OF DELETING A CUSTOMER

-- ADD A DUMMY RECORD WITH AN INVOICELINE ITEM THAT DEPENDS ON IT
BEGIN
	INSERT INTO INVOICE (INVOICEID, CUSTOMERID, INVOICEDATE, TOTAL)
	VALUES (500, 1, TO_DATE('2018-12-08', 'YYYY-MM-DD'), 10.0);
	INSERT INTO INVOICELINE
	VALUES (2300, 500, 1, 0.99, 1);
	COMMIT;
END;

-- DELETE THE DUMMY RECORD
DECLARE
	I_ID INT;
BEGIN
	I_ID := 500;
	DELETE FROM INVOICE
	WHERE INVOICEID = I_ID;
	COMMIT;
END;


-- ==========SECTION 6 TRIGGERS========== --

-- IMPORTANT! IN ORDER TO DEMONSTRATE THE EFFECTS OF TRIGGERS, I CREATED A NEW TABLE CALLED CHANGELOG
-- THIS TABLE KEEPS A RECORD OF CERTAIN CHANGES TO THE DATABASE. NAMELY, AFTER A DML STATEMENT IS EXECUTED,
-- A NEW ENTRY WILL APPEAR IN CHANGELOG TABLE WITH INFORMATION OF THE CHANGE.
CREATE TABLE CHANGELOG (
	CHANGEID INT PRIMARY KEY,
	TABLENAME VARCHAR2(30),
	RECORDID INT,
	CHANGETYPE VARCHAR2(10),
	CHANGEDATE DATE
);

-- ALSO CREATE A LOG SEQUENCE
CREATE SEQUENCE SEQ_CHANGELOG_ID
START WITH 1
INCREMENT BY 1;

-- 6.1 AFTER/FOR --

-- TASK: CREATE AN AFTER INSERT TRIGGER ON THE EMPLOYEE TABLE FIRED AFTER A NEW RECORD IS INSERTED INTO THE TABLE.
CREATE OR REPLACE TRIGGER TR_EMPLOYEE_INSERT
AFTER INSERT
ON EMPLOYEE
FOR EACH ROW
BEGIN
	INSERT INTO CHANGELOG
	VALUES (SEQ_CHANGELOG_ID.NEXTVAL, 'EMPLOYEE', :NEW.EMPLOYEEID, 'INSERT', CURRENT_TIMESTAMP);
END;

-- TASK: CREATE AN AFTER UPDATE TRIGGER ON THE ALBUM TABLE THAT FIRES AFTER A ROW IS INSERTED IN THE TABLE.
CREATE OR REPLACE TRIGGER TR_ALBUM_INSERT
AFTER INSERT
ON ALBUM
FOR EACH ROW
BEGIN
	INSERT INTO CHANGELOG
	VALUES (SEQ_CHANGELOG_ID.NEXTVAL, 'ALBUM', :NEW.ALBUMID, 'INSERT', CURRENT_TIMESTAMP);
END;

-- TASK: CREATE AN AFTER DELETE TRIGGER ON THE CUSTOMER TABLE THAT FIRES AFTER A ROW IS DELETED FROM THE TABLE.
CREATE OR REPLACE TRIGGER TR_CUSTOMER_DELETE
AFTER DELETE
ON CUSTOMER
FOR EACH ROW
BEGIN
	INSERT INTO CHANGELOG
	VALUES (SEQ_CHANGELOG_ID.NEXTVAL, 'CUSTOMER', :OLD.CUSTOMERID, 'DELETE', CURRENT_TIMESTAMP);
END;
/
-- CREATE TRIGGERS FOR INVOICE AND INVOICELINE TABLES SINCE THEY RELY ON CUSTOMER TABLE
CREATE OR REPLACE TRIGGER TR_INVOICE_DELETE
AFTER DELETE
ON INVOICE
FOR EACH ROW
BEGIN
	INSERT INTO CHANGELOG
	VALUES (SEQ_CHANGELOG_ID.NEXTVAL, 'INVOICE', :OLD.INVOICEID, 'DELETE', CURRENT_TIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TR_INVOICELINE_DELETE
AFTER DELETE
ON INVOICELINE
FOR EACH ROW
BEGIN
	INSERT INTO CHANGELOG
	VALUES (SEQ_CHANGELOG_ID.NEXTVAL, 'INVOICELINE', :OLD.INVOICELINEID, 'DELETE', CURRENT_TIMESTAMP);
END;


-- ==========SECTION 7 JOINS========== --

-- 7.1 INNER --

-- TASK: CREATE AN INNER JOIN THAT JOINS CUSTOMERS AND ORDERS AND SPECIFIES THE NAME OF THE CUSTOMER AND THE INVOICEID.
SELECT C.FIRSTNAME, C.LASTNAME, I.INVOICEID
FROM CUSTOMER C
INNER JOIN INVOICE I
ON C.CUSTOMERID = I.CUSTOMERID
ORDER BY C.CUSTOMERID;

-- 7.2 OUTER --

-- TASK: CREATE AN OUTER JOIN THAT JOINS THE CUSTOMER AND INVOICE TABLE, SPECIFYING THE CUSTOMERID, FIRSTNAME, LASTNAME, INVOICEID, AND TOTAL.
SELECT C.CUSTOMERID, C.FIRSTNAME, C.LASTNAME, I.INVOICEID, I.TOTAL
FROM CUSTOMER C
FULL OUTER JOIN INVOICE I
ON C.CUSTOMERID = I.CUSTOMERID
ORDER BY C.CUSTOMERID;

-- 7.3 RIGHT --

-- TASK: CREATE A RIGHT JOIN THAT JOINS ALBUM AND ARTIST SPECIFYING ARTIST NAME AND TITLE.
SELECT AR.NAME, AB.TITLE
FROM ALBUM AB
RIGHT JOIN ARTIST AR
ON AB.ARTISTID = AR.ARTISTID
ORDER BY AB.ARTISTID;

-- 7.4 CROSS --

-- TASK: CREATE A CROSS JOIN THAT JOINS ALBUM AND ARTIST AND SORTS BY ARTIST NAME IN ASCENDING ORDER.
SELECT AR.NAME, AB.TITLE
FROM ALBUM AB
CROSS JOIN ARTIST AR
ORDER BY AR.NAME ASC;

-- 7.5 SELF --

-- TASK: PERFORM A SELF-JOIN ON THE EMPLOYEE TABLE, JOINING ON THE REPORTSTO COLUMN.
SELECT E1.EMPLOYEEID, E1.LASTNAME, E2.EMPLOYEEID, E2.LASTNAME
FROM EMPLOYEE E1, EMPLOYEE E2
WHERE E1.EMPLOYEEID = E2.REPORTSTO
ORDER BY E1.EMPLOYEEID;


-- ==========END OF SQL LAB ASSIGNMENT========== --